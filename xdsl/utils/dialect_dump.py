import subprocess

from xdsl.ir import Attribute, TypeAttribute
from xdsl.irdl import (
    GenericAttrConstraint,
    GenericRangeConstraint,
    OpDef,
    ParamAttrDef,
    ParametrizedAttribute,
    SingleOf,
)

#########
# Functions that generate a .py file with operations' class definitions from their OpDefs
# Used by tools that generate dialects automatically
########


def generate_dynamic_attr_class(
    class_name: str, attr: ParamAttrDef, is_type: bool = True
) -> type[Attribute]:
    return type(
        class_name,
        (ParametrizedAttribute,) + ((TypeAttribute,) if is_type else ()),
        dict(ParametrizedAttribute.__dict__) | {"name": attr.name},
    )


def get_constraint_from_range(
    constr: GenericRangeConstraint[Attribute],
) -> GenericAttrConstraint[Attribute]:
    if type(constr) is not SingleOf:
        raise Exception(f"Constraint type {constr} not supported")
    return constr.constr


def typedef_to_class_string(class_name: str, typedef: ParamAttrDef) -> str:
    return f"""
@irdl_attr_definition
class {class_name}(ParametrizedAttribute, TypeAttribute):
\tname = "{typedef.name}"
    """


def attrdef_to_class_string(class_name: str, attr: ParamAttrDef) -> str:
    return f"""
@irdl_attr_definition
class {class_name}(ParametrizedAttribute):
\tname = "{attr.name}"
    """


def opdef_to_class_string(class_name: str, op: OpDef) -> str:
    field_name_mapping = {
        ir_name: field_name for (field_name, (ir_name, _)) in op.accessor_names.items()
    }

    props_str = "\n\t".join(
        [
            f"{field_name_mapping.get(name, name)} = prop_def({prop.constr}{f', prop_name="{name}"' if name in field_name_mapping else ''})"  # noqa: E501
            for name, prop in op.properties.items()
        ]
    )
    operand_str = "\n\t".join(
        [
            f"{name} = operand_def({get_constraint_from_range(oper.constr)})"
            for name, oper in op.operands
        ]
    )
    results_str = "\n\t".join(
        [
            f"{name} = result_def({get_constraint_from_range(oper.constr)})"
            for name, oper in op.results
        ]
    )
    return f"""
@irdl_op_definition
class {class_name}(IRDLOperation):
\tname = "{op.name}"
\t{props_str}
\t{operand_str}
\t{results_str}
\t{f'assembly_format = "{op.assembly_format}"' if op.assembly_format else ""}
    """


def dump_dialect_pyfile(
    dialect_name: str,
    ops: list[tuple[str, OpDef]],
    attributes: list[tuple[str, ParamAttrDef]],
    types: list[tuple[str, ParamAttrDef]],
    file_name: str,
    generator_script: str,
    preambule: str = "",
    dialect_obj_name: str = "",
):
    if not dialect_obj_name:
        dialect_obj_name = dialect_name.capitalize() + "Dialect"

    imports = """
from xdsl.dialects.builtin import *
from xdsl.ir import *
from xdsl.irdl import *

# ruff: noqa: F403, F405
    """
    if not preambule:
        preambule = f"""
###
# This dialect is automatically generated by {generator_script}
# Please don't edit it manually!
###
        """

    types_class_defs = "\n".join(
        [typedef_to_class_string(class_name, attr) for class_name, attr in types]
    )

    attr_class_defs = "\n".join(
        [attrdef_to_class_string(class_name, attr) for class_name, attr in attributes]
    )

    op_class_defs = "\n".join(
        [opdef_to_class_string(class_name, op) for class_name, op in ops]
    )

    op_list = ",".join([name for name, _ in ops])
    attr_list = ",".join([name for name, _ in attributes + types])

    dialect_def = (
        f'{dialect_obj_name} = Dialect("{dialect_name}", [{op_list}], [{attr_list}])'
    )

    content = "\n".join(
        [
            imports,
            preambule,
            types_class_defs,
            attr_class_defs,
            op_class_defs,
            dialect_def,
        ]
    )
    print(content)
    # Format output
    output = subprocess.run(
        [
            "ruff",
            "format",
            "--stdin-filename",
            f"{dialect_name}.py",
        ],
        input=content,
        capture_output=True,
        text=True,
    )
    print(output.stderr)
    with open(file_name, "w+") as f:
        print(output.stdout, file=f, end="")
